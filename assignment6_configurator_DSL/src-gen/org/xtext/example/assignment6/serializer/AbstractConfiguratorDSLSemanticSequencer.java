/*
 * generated by Xtext
 */
package org.xtext.example.assignment6.serializer;

import assignment6_model.Assignment6_modelPackage;
import assignment6_model.BinaryDependency;
import assignment6_model.Configurator;
import assignment6_model.Group;
import assignment6_model.IntegerFeature;
import assignment6_model.IntegerValueDependency;
import assignment6_model.IsSelectedDependency;
import assignment6_model.SimpleFeature;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.assignment6.services.ConfiguratorDSLGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractConfiguratorDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ConfiguratorDSLGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == Assignment6_modelPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case Assignment6_modelPackage.BINARY_DEPENDENCY:
				if(context == grammarAccess.getBaseBinaryDependencyRule() ||
				   context == grammarAccess.getDependencyRule()) {
					sequence_BaseBinaryDependency_BinaryDependency_BinaryNotDependency(context, (BinaryDependency) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getBinaryDependencyRule()) {
					sequence_BinaryDependency(context, (BinaryDependency) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getBinaryNotDependencyRule()) {
					sequence_BinaryNotDependency(context, (BinaryDependency) semanticObject); 
					return; 
				}
				else break;
			case Assignment6_modelPackage.CONFIGURATOR:
				sequence_Configurator(context, (Configurator) semanticObject); 
				return; 
			case Assignment6_modelPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case Assignment6_modelPackage.INTEGER_FEATURE:
				sequence_IntegerFeature(context, (IntegerFeature) semanticObject); 
				return; 
			case Assignment6_modelPackage.INTEGER_VALUE_DEPENDENCY:
				sequence_IntegerValueDependency(context, (IntegerValueDependency) semanticObject); 
				return; 
			case Assignment6_modelPackage.IS_SELECTED_DEPENDENCY:
				sequence_IsSelectedDependency(context, (IsSelectedDependency) semanticObject); 
				return; 
			case Assignment6_modelPackage.SIMPLE_FEATURE:
				sequence_SimpleFeature(context, (SimpleFeature) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         (not?='NOT' leftHand=Dependency operator=BinaryOperator rightHand=Dependency) | 
	 *         (leftHand=Dependency operator=BinaryOperator rightHand=Dependency)
	 *     )
	 */
	protected void sequence_BaseBinaryDependency_BinaryDependency_BinaryNotDependency(EObject context, BinaryDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftHand=Dependency operator=BinaryOperator rightHand=Dependency)
	 */
	protected void sequence_BinaryDependency(EObject context, BinaryDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (not?='NOT' leftHand=Dependency operator=BinaryOperator rightHand=Dependency)
	 */
	protected void sequence_BinaryNotDependency(EObject context, BinaryDependency semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Assignment6_modelPackage.Literals.DEPENDENCY__NOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment6_modelPackage.Literals.DEPENDENCY__NOT));
			if(transientValues.isValueTransient(semanticObject, Assignment6_modelPackage.Literals.BINARY_DEPENDENCY__RIGHT_HAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment6_modelPackage.Literals.BINARY_DEPENDENCY__RIGHT_HAND));
			if(transientValues.isValueTransient(semanticObject, Assignment6_modelPackage.Literals.BINARY_DEPENDENCY__LEFT_HAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment6_modelPackage.Literals.BINARY_DEPENDENCY__LEFT_HAND));
			if(transientValues.isValueTransient(semanticObject, Assignment6_modelPackage.Literals.BINARY_DEPENDENCY__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Assignment6_modelPackage.Literals.BINARY_DEPENDENCY__OPERATOR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBinaryNotDependencyAccess().getNotNOTKeyword_1_0(), semanticObject.isNot());
		feeder.accept(grammarAccess.getBinaryNotDependencyAccess().getLeftHandDependencyParserRuleCall_3_0(), semanticObject.getLeftHand());
		feeder.accept(grammarAccess.getBinaryNotDependencyAccess().getOperatorBinaryOperatorEnumRuleCall_4_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getBinaryNotDependencyAccess().getRightHandDependencyParserRuleCall_5_0(), semanticObject.getRightHand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=EString (features+=Feature features+=Feature*)? (groups+=Group groups+=Group*)?)
	 */
	protected void sequence_Configurator(EObject context, Configurator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (groupType=GroupType name=EString features+=SimpleFeature features+=SimpleFeature*)
	 */
	protected void sequence_Group(EObject context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         mandatory?='mandatory'? 
	 *         name=EString 
	 *         minValue=EInt 
	 *         maxValue=EInt 
	 *         step=EInt 
	 *         (dependencies+=Dependency dependencies+=Dependency*)? 
	 *         (features+=Feature features+=Feature*)? 
	 *         (groups+=Group groups+=Group*)?
	 *     )
	 */
	protected void sequence_IntegerFeature(EObject context, IntegerFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (target=[IntegerFeature|EString] not?='NOT'? value=EInt)
	 */
	protected void sequence_IntegerValueDependency(EObject context, IntegerValueDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (target=[Feature|EString] not?='NOT'?)
	 */
	protected void sequence_IsSelectedDependency(EObject context, IsSelectedDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         mandatory?='mandatory'? 
	 *         name=EString 
	 *         (dependencies+=Dependency dependencies+=Dependency*)? 
	 *         (features+=Feature features+=Feature*)? 
	 *         (groups+=Group groups+=Group*)?
	 *     )
	 */
	protected void sequence_SimpleFeature(EObject context, SimpleFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
